name: Deploy Wisecow to Minikube (NodePort + Monitoring + KubeArmor + TLS)

on:
  push:
    branches: [main]

jobs:
  deploy-wisecow:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Start Minikube
      uses: medyagh/setup-minikube@latest

    - name: Enable NGINX Ingress
      run: minikube addons enable ingress

    - name: Verify cluster
      run: kubectl get pods -A

    - name: Build image inside Minikube
      run: minikube image build -t wisecow:local .

    - name: Generate TLS cert and create secret
      run: |
        openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
          -keyout tls.key -out tls.crt \
          -subj "/CN=wisecow.local"
        kubectl create secret tls wisecow-tls \
          --cert=tls.crt --key=tls.key

    - name: Deploy Wisecow app
      run: |
        kubectl apply -f k8s/deployment.yml
        kubectl apply -f k8s/service.yml
        kubectl apply -f k8s/ingress.yml
        kubectl wait --for=condition=Ready pod -l app=wisecow --timeout=120s

    - name: Extract NodePort and Minikube IP
      run: |
        NODE_PORT=$(kubectl get svc wisecow-service -o jsonpath="{.spec.ports[0].nodePort}")
        MINIKUBE_IP=$(minikube ip)
        echo "üåê Wisecow is externally accessible at: http://$MINIKUBE_IP:$NODE_PORT"

    - name: Test Wisecow app via NodePort
      run: |
        NODE_PORT=$(kubectl get svc wisecow-service -o jsonpath="{.spec.ports[0].nodePort}")
        MINIKUBE_IP=$(minikube ip)
        echo "Testing Wisecow app at http://$MINIKUBE_IP:$NODE_PORT"
        RESPONSE=$(curl --max-time 10 --connect-timeout 5 http://$MINIKUBE_IP:$NODE_PORT || echo "Connection failed")
        echo "$RESPONSE"
        if echo "$RESPONSE" | grep "<pre>"; then
          echo "‚úÖ Wisecow app responded correctly"
        else
          echo "‚ùå Unexpected response from Wisecow app"
          exit 1
        fi

    - name: Run system health monitoring
      run: bash scripts/system-health.sh

    - name: Run application health checker
      run: bash scripts/app-health-check.sh

    - name: Install KubeArmor via Helm
      run: |
        helm repo add kubearmor https://kubearmor.github.io/charts
        helm repo update
        helm upgrade --install kubearmor-operator kubearmor/kubearmor-operator \
          --namespace kubearmor --create-namespace

    - name: Apply KubeArmor sample config
      run: kubectl apply -f https://raw.githubusercontent.com/kubearmor/KubeArmor/main/pkg/KubeArmorOperator/config/samples/sample-config.yml

    - name: Wait for KubeArmor operator pod to be ready
      run: |
        echo "üîç Checking KubeArmor pods in 'kubearmor' namespace..."
        kubectl get pods -n kubearmor --show-labels
        echo "‚è≥ Waiting for KubeArmor operator pod to be ready..."
        for i in {1..30}; do
          STATUS=$(kubectl get pod -n kubearmor -l kubearmor-app=kubearmor-operator -o jsonpath="{.items[0].status.phase}")
          echo "Current status: $STATUS"
          if [ "$STATUS" = "Running" ]; then
            echo "‚úÖ KubeArmor operator pod is running"
            break
          fi
          sleep 5
        done

    - name: Apply KubeArmor zero-trust policy
      run: kubectl apply -f k8s/kubearmor-policy.yml

    - name: Capture KubeArmor violation logs
      run: |
        echo "‚è≥ Waiting for potential violations..."
        sleep 10
        OPERATOR_POD=$(kubectl get pods -n kubearmor -l kubearmor-app=kubearmor-operator -o jsonpath="{.items[0].metadata.name}")
        if [ -z "$OPERATOR_POD" ]; then
          echo "‚ùå Operator pod not found. Skipping log capture."
          exit 1
        fi
        echo "üìã Fetching logs from $OPERATOR_POD..."
        kubectl logs $OPERATOR_POD -n kubearmor | grep -i "Blocked" || echo "‚ö†Ô∏è No violations detected yet"
        
    - name: Clean up TLS files
      run: rm tls.crt tls.key
